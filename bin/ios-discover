#!/usr/bin/python3
""" ios-discover - characterize different IOS system binaries

This produces a `library.json` summarizing aspects of all unique binaries.
"""

from io import BytesIO
from elftools.elf.elffile import ELFFile

from sys import argv
from pathlib import Path
from enum import Enum
import json
import hashlib
import re 

from hexdump import hexdump

from binascii import hexlify
from pywiire.title import *

# -----------------------------------------------------------------------------
# Helper functions

def has_build_string(data):
    """ Returns True if the given data contains an IOS build string """
    m = re.search(b'IOSVersion.+\s\$\0', data)
    p = re.search(b'\$IOSVersion.+\s\$\n\0', data)
    return None if ((m == None) and (p == None)) else True

def is_elf(data): 
    """ Returns True if given data starts with ELF magic """
    return True if (data[0:4] == b'\x7fELF') else None

def is_elfloader(data):
    """ Returns True if given data has a valid ELFLOADER header """
    hdr_len, elf_off, elf_len = unpack(">LLL", data[0x00:0x0c])
    if (hdr_len != 0x10): return None
    ebase = hdr_len + elf_off
    return True if (data[ebase:ebase+4] == b'\x7fELF') else None


def get_build_string(data):
    """ Pull a IOS build string out of some binary """
    m = re.search(b'IOSVersion.+\s\$\0', data)
    n = re.search(b'IOSVersion.+\s\$\n\0', data)
    if (m != None): 
        return m.group(0).decode().strip('\x00').strip('\n')
    elif (n != None):
        return n.group(0).decode().strip('\x00').strip('\n')
    else:
        return None


# -----------------------------------------------------------------------------
# Helper functions

def get_elf_data(data): 
    """ Convert some bytearray to an ELFFile object """
    return ELFFile(BytesIO(data))

def get_ios_pid(elf):
    """ Given an ELFFile, return the associated IOS PID. For now we just 
    assume that there is *exactly one* PT_NOTE segment in each ELF.
    """
    pid = None
    for seg in elf.iter_segments():
        if (seg.header['p_type'] == 'PT_NOTE'):
            ndata = seg.data()
            field = unpack(">13L", ndata)
            assert (pid == None)
            pid = field[4]
    assert (pid != None)
    return IOSPID(pid)

def parse_build_string(bstring):
    """ Parse up a build string, returning a dict.
    There are only two observed patterns (at the moment).
    """
    m = re.search(bstring_pat1, bstring)
    if (m == None):
        m = re.search(bstring_pat2, bstring)

    assert (m != None)
    name = m.group(1).strip(" ")
    date = m.group(2).strip(" ")
    time = m.group(3).strip(" ")
    ram = m.group(4).strip(" ")
    branch = m.group(5).strip(" ")
    return { 'name': name, 'date': date, 'time': time, 'ram': ram, 
            'branch': branch }


# -----------------------------------------------------------------------------
# Types/containers for state

# These are regex patterns on build strings, where the groups are:
#   (module) (date) (time) (ram) (branch)

bstring_pat1 = 'IOSVersion:\s+([A-Z\d_]+)\s*:\s+((?:\d{2}\/){2}\d{2})\s+((?:\d{2}:){2}\d{2})\s+(\d{2,3})M(.*?)\s+\$'

bstring_pat2 = 'IOSVersion:\s+([A-Z\d_]+)\s*:\s+(\d{4}-\d{2}-\d{2})-(\d{2}-\d{2})\s+(\d{2,3})M(.*?)\s+\$'

class IOSPID(Enum):
    """ IOS process ID """
    KERNEL  = 0x00
    ETICKET = 0x01
    FS      = 0x02
    DIP     = 0x03
    OH0     = 0x04
    OH1     = 0x05
    EHCI    = 0x06
    SDI     = 0x07
    USBETH  = 0x08
    NET     = 0x09
    WD      = 0x0a
    WL      = 0x0b
    KD      = 0x0c
    NCD     = 0x0d
    STM     = 0x0e
    PPCBOOT = 0x0f
    SSL     = 0x10
    USB     = 0x11
    P2P     = 0x12
    WFS     = 0x13

class IOSModuleType(Enum):
    """ IOS module names; the values are observed mappings to IOS PID """
    IOSP        = 0x00
    ES          = 0x01
    FFSP        = 0x02

    DIP         = 0x03
    DI          = 0x03

    OH0         = 0x04
    OHCI0       = 0x04

    OH1         = 0x05
    EHCI        = 0x06
    SDI         = 0x07
    ETH         = 0x08
    SO          = 0x09
    WD          = 0x0a
    WL          = 0x0b
    KD          = 0x0c
    NCD         = 0x0d
    STM         = 0x0e
    SSL         = 0x10

    KBD         = 0x11
    USB_HID     = 0x11
    USB_HUB     = 0x11
    USB_MSC     = 0x11
    USB_SHARED  = 0x11
    USB_VEN     = 0x11
    USB         = 0x11

    WFSI        = 0x13
    WFSKRN      = 0x13


class IOSModule(object):
    """ Container for an IOS module ELF binary """
    def __init__(self, titleid, titlever, data):
        self.title_id = titleid
        self.title_version = titlever
        self.data = data
        self.build_string = self.__find_build_string()

    def __find_build_string(self):
        """ Pull a IOS build string out of this module's data """
        m = re.search(b'IOSVersion.+\s\$\0', self.data)
        if (m == None): return None
        else: return m.group(0).decode().strip('\x00')

class IOSKernel(object):
    """ Container for a boot stub and IOS kernel """
    def __init__(self, titleid, titlever, data):
        self.title_id = titleid
        self.title_version = titlever
        self.data = data


# -----------------------------------------------------------------------------
# Program body

outfn = "/tmp/test.json"

artifacts = {}

# Get the list of files from the current working directory
pathlist = Path(".").glob('**/*.wad')

# Iterate over each candidate WAD file
for path in pathlist:

    # Read the WAD file into memory and parse it
    pn = str(path)
    with open(pn, "rb") as f: 
        wdata = f.read()
    wad = WAD(wdata)

    # Grab title information from the TMD section
    title_type = (wad.tmd.title_id & 0xffffffff00000000) >> 32
    title_id = (wad.tmd.title_id & 0xffffffff)
    title_version = wad.tmd.title_version
    ios_major = title_id
    ios_minor = title_version

    # Ignore files that aren't 'system titles'
    if (TitleType(title_type) != TitleType.SYSTEM): continue

    # Ignore titles that we aren't interested in
    id_blacklist = [TitleID.SM.value, TitleID.BOOT2.value]
    if (title_id in id_blacklist): continue

    #print("type={:08x} id={:08x} version={:04x}".format(title_type,
    #    title_id, title_version))

    # Iterate over all content entries described in the TMD
    for idx, ent in enumerate(wad.tmd.content):
        digest = hexlify(ent['digest']).decode('utf8')
        size = ent['size']

        # Skip build artifacts in the WAD (for now)
        if ((idx == 0) and (size == 0x40)): continue

        # Skip duplicate binaries we've already seen
        if (artifacts.get(digest)): continue

        cdata = wad.content_data[idx]

        if (is_elf(cdata)):
            elf = get_elf_data(cdata)
            pid = get_ios_pid(elf)

            if (has_build_string(cdata)):
                bstring = get_build_string(cdata)
                build_info = parse_build_string(bstring)
                module_name = IOSModuleType[build_info['name']]
            else:
                if (pid in [IOSPID.USB, IOSPID.WFS]):
                    print("[!] Unknown module {} {} entry {}".format(pn, pid, idx))
                else:
                    module_name = IOSModuleType(pid.value)

        elif (is_elfloader(cdata)):
            continue
        else:
            continue
            
        # Create an entry in the library for this artifact
        artifacts[digest] = module_name
        print("hash={} name={:8s}".format(digest, module_name.name))


print("[!] Discovered {} unique artifacts".format(len(artifacts)))


