#!/usr/bin/python3
""" boot1-extract - extract boot1 data from a NAND dump.
Expects a ~/.wii/boot1 with the boot1 key (the IV is zero).

Based on segher's tools, see the repository at:
    http://git.infradead.org/?p=users/segher/wii.git

NOTES:
    - This is broken? lol
"""

from sys import argv
from os.path import expanduser

from Crypto.Cipher import AES
from Crypto.Hash import SHA1

from hexdump import hexdump
from struct import pack, unpack

from hollywood_sha1 import *

PAGE_LEN = 0x800
FULL_PAGE_LEN = PAGE_LEN + 0x40
CLUSTER_LEN = FULL_PAGE_LEN * 8
BLOCK_LEN = CLUSTER_LEN * 8
IV = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

if (len(argv) < 2):
    print("usage: boot1-extract <nand.bin path> [--otp]")
    print("Decrypt boot1 and write contents to ./boot1.bin")
    print("  --otp      Use ~/.wii/otp.bin to verify hash")
    exit()

# -----------------------------------------------------------------------------
# Try to read in the boot1 key and the first few blocks from raw NAND.
# Optionally read a ~/.wii/otp.bin (to compare against a hash from OTP).

try:
    with open(expanduser("~/.wii/boot1"), "rb") as f:
        KEY = bytearray(f.read())
        assert len(KEY) == 0x10
except:
    print("Couldn't read boot1 key from {}".format(expanduser("~/.wii/boot1")))
    exit()

try:
    with open(argv[1], "rb") as f:
        data = bytearray(f.read(BLOCK_LEN * 16))
except:
    print("Couldn't read {}".format(argv[1]))
    exit()

if ((len(argv) >= 3) and (argv[2] == "--otp")):
    with open(expanduser("~/.wii/otp.bin"), "rb") as f:
        otp_hash_bin = bytearray(f.read(0x14))
        otp_hash_str = ''.join('{:02x}'.format(x) for x in otp_hash_bin)
        print("[*] OTP boot1 digest:\t {}".format(otp_hash_str))
        print()

# -----------------------------------------------------------------------------
# Decrypt boot1 and compute a SHA1 digest over the data

aes = AES.new(KEY, AES.MODE_CBC, IV)
boot1_sha = SHA1.new()

x = Sha1Hash()

# Compute SHA1 digest over the boot1 data
pagenum = 0

raw_data = bytearray()
while True:
    if (pagenum > 0x30): break
    

    page_base = FULL_PAGE_LEN * pagenum
    page_tail = page_base + FULL_PAGE_LEN
    page_data = bytearray(data[page_base:page_tail])
    page_contents = bytearray(page_data[0:PAGE_LEN])

    print("page_data @ {}, len={}".format(hex(id(page_data)), hex(len(page_data))))
    print("page_contents @ {}, len={}".format(hex(id(page_contents)), hex(len(page_contents))))

    # Decrypt the data
    raw_page_data = bytearray()
    raw_page_data += aes.decrypt(page_contents)
    print("raw_page_data @ {}, len={}, {}".format(hex(id(raw_page_data)), hex(len(raw_page_data)), type(raw_page_data)))


    if (pagenum == 0):
        with open("/tmp/page0.bin", "wb") as f:
            f.write(raw_page_data)


    boot1_sha.update(raw_page_data)
    print("[*] NAND digest:\t {}".format(boot1_sha.hexdigest()))

    # Append to output data and increment the page
    raw_data += raw_page_data
    pagenum += 1

print("[*] NAND boot1 digest:\t {}".format(boot1_sha.hexdigest()))

with open("boot1.bin", "wb") as f:
    f.write(raw_data)
    print("[*] Wrote 0x{:x} bytes to boot1.bin".format(len(raw_data)))
