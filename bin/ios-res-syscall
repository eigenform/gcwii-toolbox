#!/usr/bin/python3
'''res-syscall
Given some IOS58 kernel binary and a syscall number, resolve information about
syscalls (up to 0x7a) in the IOS kernel ELF.

This computes the offset to the syscall table in the binary. If you wanted to 
translate to the corresponding virtual address, you could just define the 
`VIRTUAL_BASE` corresponding to `OFFSET_BASE` by looking in the ELF headers. 
It seems like the syscall table is the second-to-last LOAD section in the ELF.
'''

from struct import pack, unpack
from sys import argv
from enum import Enum

class syscall_name(Enum):
    """ Syscall names; incomplete and occasionally wrong """
    thread_create               = 0x00
    thread_join                 = 0x01
    thread_cancel               = 0x02
    thread_get_id               = 0x03
    thread_get_pid              = 0x04
    thread_continue             = 0x05
    thread_suspend              = 0x06
    thread_yield                = 0x07
    thread_get_prio             = 0x08
    thread_set_prio             = 0x09

    mqueue_create               = 0x0a
    mqueue_destroy              = 0x0b
    mqueue_send                 = 0x0c
    mqueue_jam                  = 0x0d
    mqueue_recv                 = 0x0e

    mqueue_register_handler     = 0x0f
    mqueue_destroy_handler      = 0x10

    timer_create                = 0x11
    timer_restart               = 0x12
    timer_stop                  = 0x13
    timer_destroy               = 0x14
    time_now                    = 0x15

    heap_create                 = 0x16
    heap_destroy                = 0x17
    heap_alloc                  = 0x18
    heap_alloc_aligned          = 0x19
    heap_free                   = 0x1a
    register_device             = 0x1b

    ios_open                    = 0x1c
    ios_close                   = 0x1d
    ios_read                    = 0x1e
    ios_write                   = 0x1f
    ios_seek                    = 0x20
    ios_ioctl                   = 0x21
    ios_ioctlv                  = 0x22

    ios_open_async              = 0x23
    ios_close_async             = 0x24
    ios_read_async              = 0x25
    ios_write_async             = 0x26
    ios_seek_async              = 0x27
    ios_ioctl_async             = 0x28
    ios_ioctlv_async            = 0x29
    ios_resource_reply          = 0x2a

    set_uid                     = 0x2b
    get_uid                     = 0x2c
    set_gid                     = 0x2d
    get_gid                     = 0x2e

    ahb_memflush                = 0x2f
    cc_ahb_memflush             = 0x30

    swirq31                     = 0x31
    swirq18                     = 0x32
    swirq7or8                   = 0x33
    swirq                       = 0x34

    iobuf_pool_access           = 0x35
    iobuf_alloc                 = 0x36
    iobuf_free                  = 0x37
    iobuf_log_header_info       = 0x38
    iobuf_log_buffer_info       = 0x39
    iobuf_extend                = 0x3a
    iobuf_push                  = 0x3b
    iobuf_pull                  = 0x3c
    iobuf_verify                = 0x3d

    syscall_3e                  = 0x3e

    sync_before_read            = 0x3f
    sync_after_write            = 0x40

    ppc_boot                    = 0x41
    ios_boot                    = 0x42
    boot_new_ios_kernel         = 0x43

    di_reset_assert             = 0x44
    di_reset_deassert           = 0x45
    di_reset_check              = 0x46

    syscall_47                  = 0x47
    syscall_48                  = 0x48
    syscall_49                  = 0x49
    syscall_4a                  = 0x4a

    kernel_debug_print          = 0x4b
    kernel_set_version          = 0x4c
    kernel_get_version          = 0x4d

    syscall_4e                  = 0x4e

    virt_to_phys                = 0x4f

    dvdvideo_set                = 0x50
    dvdvideo_get                = 0x51
    syscall_52                  = 0x52
    syscall_53                  = 0x53

    set_ahbprot                 = 0x54
    get_busclock                = 0x55
    poke_gpio                   = 0x56

    syscall_57                  = 0x57
    syscall_58                  = 0x58
    syscall_59                  = 0x59
    syscall_5a                  = 0x5a

    syscall_5b                  = 0x5b
    syscall_5c                  = 0x5c
    syscall_5d                  = 0x5d
    syscall_5e                  = 0x5e
    syscall_5f                  = 0x5f
    syscall_60                  = 0x60
    syscall_61                  = 0x61
    syscall_62                  = 0x62
    syscall_63                  = 0x63
    syscall_64                  = 0x64
    syscall_65                  = 0x65
    syscall_66                  = 0x66
    syscall_67                  = 0x67
    syscall_68                  = 0x68
    syscall_69                  = 0x69
    syscall_6a                  = 0x6a
    syscall_6b                  = 0x6b
    syscall_6c                  = 0x6c
    syscall_6d                  = 0x6d
    syscall_6e                  = 0x6e
    syscall_6f                  = 0x6f

    syscall_70                  = 0x70
    syscall_71                  = 0x71
    syscall_72                  = 0x72
    syscall_73                  = 0x73
    syscall_74                  = 0x74
    syscall_75                  = 0x75
    syscall_76                  = 0x76
    syscall_77                  = 0x77
    syscall_78                  = 0x78
    syscall_79                  = 0x79
    syscall_7a                  = 0x7a


SYSCALL_NR_MAX  = 0x7a          # The maximum number of defined syscalls
INSTR_BASE      = 0xe6000010    # This is the base of the syscall opcodes
OFFSET_BASE     = 0x00028360    # Offset of syscall table base in the ELF

if (len(argv) < 2):
    print("Usage: res-syscall <kernel.elf>")
    exit(0)

syscalls = []
with open(argv[1], "rb") as f: 
    data = f.read()

for nr in range(0, SYSCALL_NR_MAX):

    # Get the syscall number and offset from the base of the table.
    # For instructions, it'd be `((instr & 0x00ffffe0) >> 5)`

    instr       = (INSTR_BASE + (nr << 5))
    file_off   = (OFFSET_BASE + (nr * 4))

    # Resolve the address of the actual implementation.
    # When the handler does `bx fp` to the address, the lowest-order bit
    # determines if we will enter THUMB mode (so we need to unset it here).

    impl_addr   = unpack(">L",data[file_off:file_off+4])[0] & ~1
    syscalls.append({'nr': nr, 'instr': instr, 'file_off': file_off, 
        'impl_addr': impl_addr, })

for call in syscalls:
    print("nr={:02x} impl=0x{:08x} instr={:08x} {}".format(call['nr'], 
        call['impl_addr'], call['instr'], syscall_name(call['nr']).name))
