#!/usr/bin/python3
""" stfu - STarlet FUzzer

   This place is a message...  
   and part of a system of messages ...
   pay attention to it!

                   Sending this message was important to us. 
               We considered ourselves to be a powerful culture.

                                      This place is not a place of honor ...  
                             no highly esteemed deed is commemorated here... 
                                                     nothing valued is here.
"""

from __future__ import print_function
from unicorn import *
from unicorn.arm_const import *
from unicorn.unicorn_const import *
from capstone import *

import signal

from hexdump import hexdump
from binascii import hexlify, unhexlify

from struct import pack, unpack
from sys import argv


def hexdump_indent(data, lvl):
    """ Hexdump wrapper with indentation """
    indent = '\t' * lvl
    for line in hexdump(data, result='generator'):
        print("{}{}".format(indent, line))


class AHBInterface(object):
    def __init__(self, parent):
        self.starlet = parent
        self.flush_req = 0
        self.spare0_flags = 0

    def update(self):
        # Immediately ACK flush requests (i think this is how this works)
        req = self.starlet.read16(0x0d8b4228)
        if (req != 0):
            print("[*] AHB acked flush request {:04x}".format(req))
            self.starlet.write16(0x0d8b422a, req)

        spare0 = self.starlet.read32(0x0d800188)
        if (self.spare0_flags != spare0):
            self.spare0_flags = spare0
            boot0 = self.starlet.read32(0x0d80018c)
            if ((spare0 & 0x10000) != 0x10000): 
                boot0 |= 9
            else:
                boot0 &= 0xffffffff6
            self.starlet.write32(0x0d80018c, boot0)
            print("[*] PLAT: Spare 0 write {:08x}, set boot0 to {:08x}"\
                    .format(spare0, boot0))


class GPIOInterface(object):
    def __init__(self, parent):
        self.starlet = parent
        self.arm_out = 0

    def update(self):
        out = self.starlet.read32(0x0d8000e0)
        if (self.arm_out != out):
            print("[!] ARMGPIO output set to {:08x}".format(out))
            self.arm_out = out
        

NAND_FLAG_WAIT          = 0x08
NAND_FLAG_WRITE         = 0x04
NAND_FLAG_READ          = 0x02
NAND_FLAG_ECC           = 0x01
NAND_CMD_RESET          = 0x00
NAND_CMD_READ0b         = 0x30
NAND_PAGE_LEN           = 0x840

class NANDInterface(object):
    def __init__(self, parent):
        self.starlet = parent
        self.command = 0

        # Mock NAND data
        self.data = bytearray()
        #self.data += b'\xde\xad\xbe\xef' * 0x100000

    def update(self):
        ctrl = self.starlet.read32(0x0d010000)

        # Handle a command
        if (ctrl & 0x80000000):

            mask = (ctrl & 0x1f000000) >> 24
            cmd = (ctrl & 0x00ff0000) >> 16
            flags = (ctrl & 0x0000f000) >> 12
            datasize = (ctrl & 0x00000fff)

            print("[*] NAND mask={:02x} cmd={:02x} flags={:02x} size={:04x}"\
                    .format(mask, cmd, flags, datasize))

            # Just use command and size to infer what needs to happen?
            if (cmd == NAND_CMD_RESET):
                print("[*] NAND RESET")
                self.clear_command(ctrl)
            elif(cmd == NAND_CMD_READ0b):
                addr0           = self.starlet.read32(0x0d010008)
                addr1           = self.starlet.read32(0x0d01000c)
                dma_data_addr   = self.starlet.read32(0x0d010010)
                dma_ecc_addr    = self.starlet.read32(0x0d010014)

                print("[*] NAND READ data={:08x} ecc={:08x} a0={:08x} a1={:08x}"\
                    .format(dma_data_addr, dma_ecc_addr, addr0, addr1))

                if (datasize == 0x840):
                    nand_data = self.nand_read(addr0, addr1, datasize)
                    self.starlet.dma_write(dma_data_addr, nand_data[0:0x800])
                    self.starlet.dma_write(dma_ecc_addr, nand_data[0x800:0x840])

                    if ((flags & NAND_FLAG_ECC) == NAND_FLAG_ECC):
                        self.starlet.write32(((dma_ecc_addr ^ 0x40) + 0x00), 0)
                        self.starlet.write32(((dma_ecc_addr ^ 0x40) + 0x04), 0)
                        self.starlet.write32(((dma_ecc_addr ^ 0x40) + 0x08), 0)
                        self.starlet.write32(((dma_ecc_addr ^ 0x40) + 0x0c), 0)

                    print("[!] NAND DMA write to {:08x}".format(dma_data_addr))
                    hexdump_indent(self.starlet.dma_read(dma_data_addr,0x840), 1)
                    self.clear_command(ctrl)
                else:
                    print("[*] NAND unimpl datasize")
                    self.starlet.halt()
            else:
                print("[*] NAND: Unhandled cmd {:02x} ({:08x})".format(cmd, ctrl))
                self.starlet.halt()

    def clear_command(self, ctrl):
        """ Clear NAND_CTRL busy bit exposed to ARM """
        self.starlet.write32(0x0d010000, ctrl & 0x7fffffff)

    def nand_read(self, addr0, addr1, size):
        """ Return bytes from the underlying NAND device """
        off = addr1 * NAND_PAGE_LEN
        return self.data[off:off + size]


class StarletIO(object):
    def __init__(self, parent):
        assert type(parent) == Starlet
        self.timer = 0
        self.starlet = parent
        self.nand = NANDInterface(parent)
        self.ahb = AHBInterface(parent)
        self.gpio = GPIOInterface(parent)

    def update(self):
        """ Update various aspects of I/O or chipset state """
        self.timer += self.starlet.last_block_size * 0x10
        self.starlet.write32(0x0d800010, self.timer)
        self.nand.update()
        self.ahb.update()
        self.gpio.update()


class Starlet(object):
    def __init__(self):
        self.running = False
        self.code_loaded = False
        self.symbols = {}
        self.last_block_size = 0
        self.block_count = 0
        self.last_mmio_pc = 0

        self.dis_arm = Cs(CS_ARCH_ARM, CS_MODE_ARM | CS_MODE_BIG_ENDIAN)
        self.dis_thumb = Cs(CS_ARCH_ARM, CS_MODE_THUMB | CS_MODE_BIG_ENDIAN)

        self.mu = Uc(UC_ARCH_ARM, UC_MODE_ARM | UC_MODE_BIG_ENDIAN)
        self.mu.parent = self
        self.io = StarletIO(self)
        self.__init_mmu()
        self.__init_hook()
    
    def import_nand(self, filename):
        """ Load a NAND dump (reading it all into memory at once) """
        with open(filename, "rb") as f:
            self.io.nand.data = f.read()
        print("[*] Imported NAND from {} ({:08x})".format(filename,
            len(self.io.nand.data)))


    def find_symbol(self, addr):
        target = min(self.symbols, key=lambda x: abs(x - addr))
        return self.symbols[target]

    def get_symbol(self, addr):
        """ Directly fetch a symbol """
        if (self.symbols):
            return self.symbols.get(addr)
        else:
            return None

    def import_symbols(self, filename):
        """ this is awful """
        assert self.running == False
        with open(filename, "rb") as f:
            for line in f.readlines():
                l = line.decode('utf-8').replace('"', "")
                x = l.split(',')
                addr = int(x[0], 16)
                name = x[1]
                self.symbols[addr] = name
        print("[*] Imported {} symbols from {}".format(len(self.symbols),
            filename))

    def __get_breakpoint_func(self):
        def breakpoint_hook(uc, address, size, user_data):
            starlet = uc.parent
            print("[*] Breakpoint at pc={:08x}".format(address))

            # Disassemble directly at the breakpoint
            starlet.disas(address, 0x20);

            starlet.halt()
        return breakpoint_hook

    def add_breakpoint(self, addr):
        self.mu.hook_add(UC_HOOK_CODE, self.__get_breakpoint_func(), 
                begin=addr, end=addr)

    def disas(self, addr, size):
        """ Disassemble some amount of bytes at address """
        data = self.mu.mem_read(addr, size)

        # FIXME: this isn't a good strategy
        #if ((addr & 2) == 2):
        #    print("[*] Disassembling in THUMB mode")
        #    instrs = self.dis_thumb.disasm(data, addr, count=size)
        #else:
        #    print("[*] Disassembling in ARM mode")
        #    instrs = self.dis_arm.disasm(data, addr, count=size)

        instrs = self.dis_thumb.disasm(data, addr, count=size)

        print("[!] Disassembly request at {:08x}".format(addr))
        for instr in instrs:
            ad = instr.address
            ib = hexlify(instr.bytes).decode('utf-8')
            mn = instr.mnemonic
            op = instr.op_str
            print("\t{:08x}: \t{}\t{}\t{}".format(ad, ib, mn, op))

    def run(self):
        assert self.code_loaded == True
        try:
            self.mu.emu_start(self.entrypoint, self.entrypoint + self.codelen)
            self.running = True
        except UcError as e:
            print("[!] ERROR: %s".format(e))
            self.dump_state()
            self.running = False

    def halt(self):
        self.mu.emu_stop()
        print("[!] Halted emulation")
        self.dump_state()
        self.running = False

    def __init_mmu(self):
        self.mu.mem_map(0x0d400000, 0x00020000) # SRAM
        self.mu.mem_map(0x00000000, 0x01800000) # MEM1
        self.mu.mem_map(0x10000000, 0x04000000) # MEM2
        self.mu.mem_map(0x0d800000, 0x00000400) # Hollywood registers
        self.mu.mem_map(0x0d806000, 0x00000400) # EXI registers
        self.mu.mem_map(0x0d8b0000, 0x00008000) # Memory controller interface?
        self.mu.mem_map(0x0d010000, 0x00001000) # NAND interface
        self.mu.mem_map(0x0d020000, 0x00001000) # AES interface
        self.mu.mem_map(0x0d030000, 0x00001000) # SHA interface


    def __get_locinfo(self, addr):
        """ Format string things """
        if (self.symbols):
            sym = self.find_symbol(addr)
            return "in {} ({:08x})".format(sym, addr) if sym else "@ pc={:08x}"\
                    .format(addr)
        else:
            return "@ pc={:08x}".format(addr)


    def __get_mmio_func(self, mmio_name):
        """ Generate an MMIO-handler function """
        def mmio_handler_func(uc, access, address, size, value, user_data):
            starlet = uc.parent
            this_pc = uc.reg_read(UC_ARM_REG_PC)


            accinfo = "write" if access == UC_MEM_WRITE else "read"
            valinfo = "{:08x}".format(value) if access == UC_MEM_WRITE else ""
            locinfo = starlet.__get_locinfo(this_pc)

            if (starlet.last_mmio_pc != this_pc):
                print("[*] {} {} at {:08x}\t {}".format(mmio_name, accinfo,
                    address, locinfo))
                
            starlet.last_mmio_pc = this_pc
        return mmio_handler_func

    def __register_mmio(self, name, addr, size):
        """ Register an MMIO hook for some address space """
        self.mu.hook_add(UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, 
                self.__get_mmio_func(name), begin=addr, end=(addr + size))

    def __get_err_unmapped_func(self):
        """ Generate a handler for un-mapped memory accesses """
        def hook_unmapped(uc, access, address, size, value, user_data):
            pc = uc.reg_read(UC_ARM_REG_PC)
            acc_type = "write" if access == UC_MEM_WRITE_UNMAPPED else "read"
            print("[!] MMU error: pc={:08x} Unmapped {} {:08x} on {:08x}".format(
                pc, acc_type, value, address))
            return False
        return hook_unmapped

    def __get_basic_block_func(self):
        """ Generate a basic block hook """
        def basic_block_hook(uc, address, size, user_data):
            starlet = uc.parent

            #print("[*] Basic block at {:08x} ({})".format(address,
            #    starlet.find_symbol(address)))

            # Potential service any outstanding I/O work
            starlet.io.update()

            starlet.last_block_size = size
            starlet.block_count += 1
        return basic_block_hook

    def __init_hook(self):
        # Note that the range isn't inclusive.
        self.__register_mmio("NAND",    0x0d010000, 0x20)
        self.__register_mmio("IPC",     0x0d800000, 0xc)
        self.__register_mmio("TIMER",   0x0d800010, 0x4)
        self.__register_mmio("INTR",    0x0d800030, 0x2c)
        self.__register_mmio("PROT",    0x0d800060, 0x1c)
        self.__register_mmio("PPCGPIO", 0x0d8000c0, 0x18)
        self.__register_mmio("ARMGPIO", 0x0d8000dc, 0x20)
        self.__register_mmio("AHB",     0x0d800100, 0x4c)
        self.__register_mmio("PLAT",    0x0d800180, 0x20)
        self.__register_mmio("CLK",     0x0d8001b0, 0x38)
        self.__register_mmio("EFUSE",   0x0d8001ec, 0x4)
        self.__register_mmio("MISC",    0x0d8001f4, 0x2c)
        self.__register_mmio("FLUSH",   0x0d8b4228, 0x2)

        # Error handling hooks
        self.mu.hook_add(UC_HOOK_MEM_UNMAPPED, self.__get_err_unmapped_func())

        # This hook handles MMIO
        self.mu.hook_add(UC_HOOK_BLOCK, self.__get_basic_block_func())

    def load_code(self, filename, addr):
        """ Load some binary into memory at some address """
        assert self.running == False
        with open(filename, "rb") as f:
            ARM_CODE = f.read()
        self.mu.mem_write(addr, ARM_CODE)
        self.entrypoint = addr
        self.codelen = len(ARM_CODE)
        self.code_loaded = True

    # Memory access primitives
    def read32(self, addr): return unpack(">L", self.mu.mem_read(addr, 4))[0]
    def read16(self, addr): return unpack(">H", self.mu.mem_read(addr, 2))[0]
    def write32(self, addr, val): self.mu.mem_write(addr, pack(">L", val))
    def write16(self, addr, val): self.mu.mem_write(addr, pack(">H", val))
    def dma_write(self, addr, data): 
        self.mu.mem_write(addr, bytes(data))
    def dma_read(self, addr, size): return self.mu.mem_read(addr, size)

    def dump_state(self):
        pc = self.mu.reg_read(UC_ARM_REG_PC)
        lr = self.mu.reg_read(UC_ARM_REG_LR)
        sp = self.mu.reg_read(UC_ARM_REG_SP)
        r0 = self.mu.reg_read(UC_ARM_REG_R0)
        r1 = self.mu.reg_read(UC_ARM_REG_R1)
        r2 = self.mu.reg_read(UC_ARM_REG_R2)
        r3 = self.mu.reg_read(UC_ARM_REG_R3)
        r4 = self.mu.reg_read(UC_ARM_REG_R4)
        r5 = self.mu.reg_read(UC_ARM_REG_R5)
        r6 = self.mu.reg_read(UC_ARM_REG_R6)
        r7 = self.mu.reg_read(UC_ARM_REG_R7)
        r8 = self.mu.reg_read(UC_ARM_REG_R8)
        r9 = self.mu.reg_read(UC_ARM_REG_R9)

        fmt = """pc={:08x} lr={:08x} sp={:08x}\
            \nr0={:08x} r1={:08x} r2={:08x} r3={:08x} r4={:08x} r5={:08x}\
            \nr6={:08x} r7={:08x} r8={:08x} r9={:08x} """
        print(fmt.format(pc,lr,sp,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9))


# -----------------------------------------------------------------------------

if (len(argv) < 3):
    print("usage: {} <ARM binary> <NAND dump>".format(argv[0]))
    exit()

def sig_handle(sig, frame):
    print("[!] Caught SIGINT, halting ...")
    emu.halt()

signal.signal(signal.SIGINT, sig_handle)


emu = Starlet()
emu.load_code(argv[1], 0x0d400000)
emu.import_symbols("wow.csv")
emu.import_nand(argv[2])
emu.run()

