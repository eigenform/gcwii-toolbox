#!/usr/bin/python3
""" stfu - STarlet FUzzer

   This place is a message...  
   and part of a system of messages ...
   pay attention to it!

                   Sending this message was important to us. 
               We considered ourselves to be a powerful culture.

                                      This place is not a place of honor ...  
                             no highly esteemed deed is commemorated here... 
                                                     nothing valued is here.
"""

from __future__ import print_function
from unicorn import *
from unicorn.arm_const import *
from unicorn.unicorn_const import *
from capstone import *

import signal
from binascii import hexlify, unhexlify
from struct import pack, unpack
from sys import argv

from libstfu.io import *
from libstfu.util import *


class Starlet(object):
    def __init__(self):
        self.running = False
        self.code_loaded = False
        self.code_entrypoint = None
        self.mmio_logging = True
        self.use_boot0 = False
        self.symbols = {}
        self.last_block_size = 0
        self.block_count = 0
        self.last_mmio_pc = 0

        self.dis_arm = Cs(CS_ARCH_ARM, CS_MODE_ARM | CS_MODE_BIG_ENDIAN)
        self.dis_thumb = Cs(CS_ARCH_ARM, CS_MODE_THUMB | CS_MODE_BIG_ENDIAN)

        self.mu = Uc(UC_ARCH_ARM, UC_MODE_ARM | UC_MODE_BIG_ENDIAN)
        self.mu.parent = self
        self.io = StarletIO(self)
        self.__init_mmu()
        self.__init_hook()

    def load_boot0(self, filename):
        with open(filename, "rb") as f:
            data = f.read()
        self.mu.mem_write(0xffff0000, data)
    
    def load_nand(self, filename):
        """ Load a NAND dump (reading it all into memory at once) """
        with open(filename, "rb") as f:
            self.io.nand.data = f.read()
        print("[*] Imported NAND from {} ({:08x})".format(filename,
            len(self.io.nand.data)))

    def find_symbol(self, addr):
        """ wow this is awful """
        syms = [ addr for addr in self.symbols ]
        syms.sort()
        target = min(range(len(syms)), key=lambda x: abs(syms[x] - addr))
        if (syms[target] > addr):
            target = target - 1
        func_addr = syms[target]
        return self.symbols[func_addr]

    def get_symbol(self, addr):
        """ Directly fetch a symbol """
        if (self.symbols):
            return self.symbols.get(addr)
        else:
            return None

    def load_symbols(self, filename):
        """ this is awful """
        assert self.running == False
        with open(filename, "rb") as f:
            for line in f.readlines():
                l = line.decode('utf-8').replace('"', "")
                x = l.split(',')
                addr = int(x[0], 16)
                name = x[1]
                self.symbols[addr] = name
        print("[*] Imported {} symbols from {}".format(len(self.symbols),
            filename))

    def __get_logrange_func(self):
        def logrange_hook(uc, address, size, user_data):
            starlet = uc.parent
            print("[*] Logpoint at {}".format(self.__get_locinfo(address)))
        return logrange_hook

    def __get_breakpoint_func(self):
        def breakpoint_hook(uc, address, size, user_data):
            starlet = uc.parent
            print("[*] Breakpoint at pc={:08x}".format(address))

            # Disassemble directly at the breakpoint
            starlet.disas(address, 0x20);

            starlet.halt()
        return breakpoint_hook

    def add_breakpoint(self, addr):
        self.mu.hook_add(UC_HOOK_CODE, self.__get_breakpoint_func(), 
                begin=addr, end=addr)

    def add_logrange(self, addr, size):
        self.mu.hook_add(UC_HOOK_CODE, self.__get_logrange_func(),
                begin=addr, end=(addr+size))

    def disas(self, addr, size):
        """ Disassemble some amount of bytes at address """
        data = self.mu.mem_read(addr, size)

        # FIXME: this isn't a good strategy
        #if ((addr & 2) == 2):
        #    print("[*] Disassembling in THUMB mode")
        #    instrs = self.dis_thumb.disasm(data, addr, count=size)
        #else:
        #    print("[*] Disassembling in ARM mode")
        #    instrs = self.dis_arm.disasm(data, addr, count=size)

        instrs = self.dis_thumb.disasm(data, addr, count=size)

        print("[!] Disassembly request at {:08x}".format(addr))
        for instr in instrs:
            ad = instr.address
            ib = hexlify(instr.bytes).decode('utf-8')
            mn = instr.mnemonic
            op = instr.op_str
            print("\t{:08x}: \t{}\t{}\t{}".format(ad, ib, mn, op))

    def run(self):
        assert self.code_loaded == True
        if (self.use_boot0):
            self.code_entrypoint = 0xffff0000
        try:
            self.mu.emu_start(self.code_entrypoint, 
                    self.code_entrypoint + self.codelen)
            self.running = True
        except UcError as e:
            print("[!] ERROR: %s".format(e))
            self.dump_state()
            self.running = False

    def halt(self):
        self.mu.emu_stop()
        print("[!] Halted emulation")
        self.dump_state()
        self.running = False

    def __init_mmu(self):
        self.mu.mem_map(0xffff0000, 0x00002000) # SRAM

        self.mu.mem_map(0x0d400000, 0x00020000) # SRAM
        self.mu.mem_map(0x00000000, 0x01800000) # MEM1
        self.mu.mem_map(0x10000000, 0x04000000) # MEM2
        self.mu.mem_map(0x0d800000, 0x00000400) # Hollywood registers
        self.mu.mem_map(0x0d806000, 0x00000400) # EXI registers
        self.mu.mem_map(0x0d8b0000, 0x00008000) # Memory controller interface?
        self.mu.mem_map(0x0d010000, 0x00001000) # NAND interface
        self.mu.mem_map(0x0d020000, 0x00001000) # AES interface
        self.mu.mem_map(0x0d030000, 0x00001000) # SHA interface


    def __get_locinfo(self, addr):
        """ Format string things """
        if (self.symbols):
            sym = self.find_symbol(addr)
            return "in {} ({:08x})".format(sym, addr) if sym else "@ pc={:08x}"\
                    .format(addr)
        else:
            return "@ pc={:08x}".format(addr)


    def __get_mmio_func(self, mmio_name, io_device):
        """ Generate an MMIO-handler function """
        def mmio_handler_func(uc, access, address, size, value, user_data):
            starlet = uc.parent

            # Do some device-specific function
            io_device.on_access(access, address, size, value)

            if (starlet.mmio_logging == False):
                return True

            this_pc = uc.reg_read(UC_ARM_REG_PC)

            accinfo = "write" if access == UC_MEM_WRITE else "read"
            valinfo = "{:08x}".format(value) if access == UC_MEM_WRITE else ""
            locinfo = starlet.__get_locinfo(this_pc)

            if (starlet.last_mmio_pc != this_pc):
                print("[*] {} {} at {:08x}\t {}".format(mmio_name, accinfo,
                    address, locinfo))
                
            starlet.last_mmio_pc = this_pc
        return mmio_handler_func

    def __register_mmio(self, name, addr, size, io_device=None):
        """ Register an MMIO hook for some address space.  """
        if (io_device == None):
            io_device = self.io.dummy
        self.mu.hook_add(UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE, 
                self.__get_mmio_func(name, io_device), 
                begin=addr, end=(addr + size))

    def __get_err_unmapped_func(self):
        """ Generate a handler for un-mapped memory accesses """
        def hook_unmapped(uc, access, address, size, value, user_data):
            pc = uc.reg_read(UC_ARM_REG_PC)
            acc_type = "write" if access == UC_MEM_WRITE_UNMAPPED else "read"
            print("[!] MMU error: pc={:08x} Unmapped {} {:08x} on {:08x}".format(
                pc, acc_type, value, address))
            return False
        return hook_unmapped

    def __get_basic_block_func(self):
        """ Generate a basic block hook """
        def basic_block_hook(uc, address, size, user_data):
            starlet = uc.parent

            print("[*] Basic block at {:08x} ({})".format(address,
                starlet.find_symbol(address)))

            # Potential service any outstanding I/O work
            starlet.io.update()

            starlet.last_block_size = size
            starlet.block_count += 1
        return basic_block_hook

    def __init_hook(self):
        # Note that the range isn't inclusive.
        # FIXME: redo handlers for all these devices probably

        self.__register_mmio("NAND",    0x0d010000, 0x20)
        self.__register_mmio("AES",     0x0d020000, 0x20, self.io.aes)
        self.__register_mmio("SHA1",    0x0d030000, 0x20, self.io.sha)

        self.__register_mmio("IPC",     0x0d800000, 0xc)
        self.__register_mmio("TIMER",   0x0d800010, 0x4)
        self.__register_mmio("INTR",    0x0d800030, 0x2c)
        self.__register_mmio("PROT",    0x0d800060, 0x1c)
        self.__register_mmio("PPCGPIO", 0x0d8000c0, 0x18)
        self.__register_mmio("ARMGPIO", 0x0d8000dc, 0x20)
        self.__register_mmio("AHB",     0x0d800100, 0x4c)
        self.__register_mmio("PLAT",    0x0d800180, 0x20)
        self.__register_mmio("CLK",     0x0d8001b0, 0x38)
        self.__register_mmio("EFUSE",   0x0d8001ec, 0x4, self.io.otp)
        self.__register_mmio("MISC",    0x0d8001f4, 0x2c)

        self.__register_mmio("FLUSH",   0x0d8b4228, 0x2)

        # Error handling hooks
        self.mu.hook_add(UC_HOOK_MEM_UNMAPPED, self.__get_err_unmapped_func())

        # This hook handles MMIO
        self.mu.hook_add(UC_HOOK_BLOCK, self.__get_basic_block_func())

    def load_code(self, filename, addr):
        """ Load some binary into memory at some address """
        assert self.running == False
        with open(filename, "rb") as f:
            ARM_CODE = f.read()
        self.mu.mem_write(addr, ARM_CODE)
        self.code_entrypoint = addr
        self.codelen = len(ARM_CODE)
        self.code_loaded = True

    def load_otp(self, filename):
        with open(filename, "rb") as f:
            OTP_DATA = f.read()
        self.io.otp.data = OTP_DATA
        print("[*] Loaded {:08x} bytes from {} to OTP".format(len(OTP_DATA),
            filename))

    # Memory access primitives
    def read32(self, addr): return unpack(">L", self.mu.mem_read(addr, 4))[0]
    def read16(self, addr): return unpack(">H", self.mu.mem_read(addr, 2))[0]
    def write32(self, addr, val): self.mu.mem_write(addr, pack(">L", val))
    def write16(self, addr, val): self.mu.mem_write(addr, pack(">H", val))
    def dma_write(self, addr, data): 
        self.mu.mem_write(addr, bytes(data))
    def dma_read(self, addr, size): return self.mu.mem_read(addr, size)

    def dump_state(self):
        pc = self.mu.reg_read(UC_ARM_REG_PC)
        lr = self.mu.reg_read(UC_ARM_REG_LR)
        sp = self.mu.reg_read(UC_ARM_REG_SP)
        r0 = self.mu.reg_read(UC_ARM_REG_R0)
        r1 = self.mu.reg_read(UC_ARM_REG_R1)
        r2 = self.mu.reg_read(UC_ARM_REG_R2)
        r3 = self.mu.reg_read(UC_ARM_REG_R3)
        r4 = self.mu.reg_read(UC_ARM_REG_R4)
        r5 = self.mu.reg_read(UC_ARM_REG_R5)
        r6 = self.mu.reg_read(UC_ARM_REG_R6)
        r7 = self.mu.reg_read(UC_ARM_REG_R7)
        r8 = self.mu.reg_read(UC_ARM_REG_R8)
        r9 = self.mu.reg_read(UC_ARM_REG_R9)

        fmt = """pc={:08x} lr={:08x} sp={:08x}\
            \nr0={:08x} r1={:08x} r2={:08x} r3={:08x} r4={:08x} r5={:08x}\
            \nr6={:08x} r7={:08x} r8={:08x} r9={:08x} """
        print(fmt.format(pc,lr,sp,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9))


# -----------------------------------------------------------------------------

if (len(argv) < 3):
    print("usage: {} <ARM binary> <NAND dump>".format(argv[0]))
    exit()

def sig_handle(sig, frame):
    print("[!] Caught SIGINT, halting ...")
    emu.halt()

signal.signal(signal.SIGINT, sig_handle)


emu = Starlet()
emu.mmio_logging = True
emu.use_boot0 = True

emu.load_symbols("wow.csv")
emu.load_boot0("boot0.bin")
emu.load_nand(argv[2])
emu.load_otp("otp.bin")

#emu.write16(0x0d403d94, 0x4770) # skyeye boot1 sleep() patch
#emu.add_logrange(0x0d400260, 0x0d400346 - 0x0d400260)

emu.load_code(argv[1], 0x0d400000)
emu.run()

